// SPDX-FileCopyrightText: Â© 2022 Dai Foundation <www.daifoundation.org>
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.13;

// import {TimedJob} from "./base/TimedJob.sol";

import {IJob} from "./interfaces/IJob.sol";

interface SequencerLike {
    function isMaster(bytes32 network) external view returns (bool);
}

/**
 * @dev interface for the RWARegistry
 */
interface RWARegistryLike {
    enum DealStatus {
        NONE, // The deal does not exist.
        ACTIVE, // The deal is active.
        FINALIZED // The deal was finalized.
    }
    function ilkToDeal(bytes32 ilk) external view returns (DealStatus, uint248);
    function list() external view returns (bytes32[] memory);
    function count() external view returns (uint256);
    function getComponent(bytes32 ilk_, bytes32 name_) external view returns (address addr, uint88 variant);
}

/**
 * @dev interface for DaiLike
 */
interface DaiLike {
    function balanceOf(address) external view returns (uint256);
}

/**
* @dev inteface for RWaUrn2Like
*/
interface RWAUrn2Like {
    function wipe(uint256 wad) external; 
}

/**
 * @title Scheduled Urn Wipe Job
 * @author David Krett <david@w2d.co>
 * @notice Scheduled job to wipe a designated urn on a periodic basis.
 */

contract RWAJarVoidJob is IJob {

    uint public timeLastRun;
    uint public timeNextRun;

    // if a lot of jobs set high frequency every 10 minutes
    /// if jobs completed set frequency to every 2 weeks

    // constructor add frequency of variables 
    SequencerLike public immutable sequencer;
    RWARegistryLike public immutable rwaRegistry;
    RWAUrn2Like public rwaUrn2;
    DaiLike public dai;

    // --- Errors ---
    error NotMaster(bytes32 network);

    // --- Events ---
    event Work(bytes32 indexed network);
    
    constructor(address _sequencer, uint256 _duration, address _rwaRegistry, address _dai) {
        sequencer = SequencerLike(_sequencer);
        rwaRegistry = RWARegistryLike(_rwaRegistry);
        dai = DaiLike(_dai);
    }

    function work(bytes32 network, bytes calldata args) external override {
        if (!sequencer.isMaster(network)) revert NotMaster(network);
        // uint256 expiry = last + maxDuration;
        // if (block.timestamp < expiry) revert TimerNotElapsed(block.timestamp, expiry);
        (address urnAddress,) = abi.decode(args, (address, uint256));   
        // calculate the current balance and minimum of debt / balance     
        // loop over the args and try catch each wipe
        RWAUrn2Like(urnAddress).wipe(dai.balanceOf(urnAddress));
        // last = block.timestamp;
        // update();

        // emit Work(network);

    }


    function workable(bytes32 network) external view override returns (bool, bytes memory) {
        if (!sequencer.isMaster(network)) return (false, bytes("Network is not master"));
        // if (block.timestamp < last + maxDuration) return (false, bytes("Timer hasn't elapsed"));

        // if (!shouldUpdate()) return (false, bytes("shouldUpdate is false"));
        // return shouldUpdate();
    }

    // /**
    //  * @notice Checks
    //  * @dev Scheduled job to wipe a designated urn on a periodic basis.
    //  */
    // function shouldUpdate() internal view returns (bool, bytes memory) {
    //     // check if the registry contains ilks
        
    //     // check if ny of the ilks are using RWAUrn2 components
    //     uint256 dealsCount = rwaRegistry.count();
    //     bytes32[] memory dealsList = rwaRegistry.list();
    //     // encode a memory array of urn addresses
    //     address[] memory urnAddresses = new address[](dealsCount);
    //     // iterate over deals find active deals 
    //     // loop again over urnAddresses and get count 
    //     // create a dynamic array in memory of active addresses 
    //     // encode and r
    //     if (dealsCount == 0) return false;
    //     for (uint256 i = 0; i < dealsCount; i++) {
    //         bytes32 ilk = dealsList[i];
    //         (RWARegistryLike.DealStatus status,) = rwaRegistry.ilkToDeal(ilk);
    //         if (status != RWARegistryLike.DealStatus.ACTIVE) continue;
    //         try rwaRegistry.getComponent(ilk, "urn") returns (address addr, uint88 variant) {
    //             if (addr == address(0)) continue;
    //             // threshold ??
    //             if (dai.balanceOf(addr) == 0) continue;
    //             return (true, abi.encode(addr));
    //         } catch {
    //             continue;
    //         }


    //     }
        

    //     return  (false, "shouldUpdate is false");
    // }

    // function update() internal override {
    //     // get the list of urns from the registry 
    //     // check the balance of each urn 
    //     for (bytes32 ilk;  rwaRegistry.list();) {
    //         uint256 wad = dai.balanceOf(rwaUrn2.address);
    //         if (wad > 0) {
    //             rwaUrn2.wipe(wad);
    //         }
    //     }   
    // }





}
